netty(网络方面)
简单游戏实例
大数据，消息队列，简单了解
微服务
Spring家族
消息队列怎么传值到某个具体接口？或者说接口怎么知道消息队列传出来的参数是需要哪个具体接口接收的

单例模式：饿：在类加载的时候直接创建实例，懒：先不创建实例instance，在调用的时候再创建instance，枚举；
懒汉单例模式加volatile的原因
指令重排序
类加载机制和类加载器
jvm详解
守护线程和非守护线程
-=
多线程和高并发
链表栈头节点(自己的总结)：  
原子变量作为头结点；
最后通过 CAS 来更新一波栈顶指针
CAS：CAS 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。
//？？？？是不是其实没有那么多头结点，并不是每个节点都有一个实际的头结点Key，只是栈顶有一个来做标记。！（或者是队列中的头、尾节点，相同的道理）
链表栈不需要规定大小，（感觉就像是更改指针指向的位置（元素/节点））
数组栈更好理解，而且会快一点点
哨兵节点：简化边界条件，指针域为空，位于链表头指针前，next指向链表头指针，prev指向链表尾部，此时为循环双向链表
---------------
Java对象间的关系：
聚合和组合的区别:
聚合是个体离开了整体，依然可以存在.
组合是个体和整体不可以分开，个体不能离开整体单独存在.

依赖，关联 和聚合，组合的区别:
依赖，关联 : 类之间的关系是在同一层次上.
聚合，组合: 类之间的关系表现为整体和部分.
聚合 和 关联的区别：关联关系是两个对象处于同一个层次上的，比如 人和自行车就是一种关联关系，而不是聚合关系，因为人不是由自行车组成的；聚合关系涉及到的两个对象处于不平等的层次上，一个代表整体， 一个代表部分，比如 汽车 和 引擎、轮胎，因为汽车是由它们组成的。
组合是一种强烈包含的关系，比如人 和 手，手离开了人就没有任何作用。组合：表示 contains-a 的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。也使用属性表达组合关系，是关联关系的一种，是比聚合关系强的关系。
---------------
面向对象的三大特性：
1、封装
隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。
2、继承
提高代码复用性；继承是多态的前提。
3、多态
父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。
五大基本原则：
1、单一职责原则SRP(Single Responsibility Principle)
类的功能要单一，不能包罗万象，跟杂货铺似的。
2、开放封闭原则OCP(Open－Close Principle)
一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。
3、里式替换原则LSP(the Liskov Substitution Principle LSP)
子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~
4、依赖倒置原则DIP(the Dependency Inversion Principle DIP)
高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的是抽象的中国人，而不是你是xx村的。
5、接口分离原则ISP(the Interface Segregation Principle ISP)
设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。
---------------
static final：

static修饰的属性强调它们只有一个，final修饰的属性表明是一个常数（创建后不能被修改）。static final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。

static final也可以修饰方法，表示该方法不能重写，可以在不new对象的情况下调用
static final和final static没什么区别，一般static写在前面。
---------------
原子变量：
Java给我们提供了以下几种原子类型：
AtomicInteger和AtomicIntegerArray：基于Integer类型
AtomicBoolean：基于Boolean类型
AtomicLong和AtomicLongArray：基于Long类型
AtomicReference和AtomicReferenceArray：基于引用类型

原子变量和synchronized关键字的区别。

从思维模式上看，原子变量代表一种乐观的非阻塞式思维，它假定没有别人会和我同时操作某个变量，于是在实际修改变量的值的之前不会锁定该变量，但是修改变量的时候是使用CAS进行的，一旦发现冲突，继续尝试直到成功修改该变量。

而synchronized关键字则是一种悲观的阻塞式思维，它认为所有人都会和我同时来操作某个变量，于是在将要操作该变量之前会加锁来锁定该变量，进而继续操作该变量。
---------------
super（）代表父类的引用，括号内的不同参数类型，顺序和个数，代表不同的构造方法。也可以用 super.属性（方法）名 来调用父类的属性（方法）
this（）代表本类的引用，括号内的不同参数类型，顺序和个数，代表不同的构造方法。也可以用 this.属性（方法）名 来调用本类的属性（方法）
---------------
被volatile声明的变量主要有以下两种特性保证保证线程安全。
1 可见性。
2 有序性。

volatile关键字能够保证代码的有序性，虚拟机在进行代码编译优化的时候，不会将加了volatile的变量重排序
---------------
Java并发-懒汉式单例设计模式加volatile的原因

 class SingletonClass{
     private volatile static  SingletonClass instance = null;
  
     private SingletonClass() { }
  
     public static SingletonClass getInstance() {
         if(instance==null) {
             synchronized ( SingletonClass.class) {
                 if(instance==null)
                     instance = new  SingletonClass();
             }
         }
         return instance;
     }
 }
双重if保护：
第一个： 判断单例是否为 null
线程加锁
第二个：第一个线程进入并创建对象之后，可能也有别的线程进入了第一层判断，此时第一个线程结束后第二个线程进入，因为是单例，所以需要判断对象是否为null，
不加volatile的话：
在语句1中并不是一个原子操作，在JVM中其实是3个操作：
1.给instance分配空间、
2.调用 Singleton 的构造函数来初始化、
3.将instance对象指向分配的内存空间（instance指向分配的内存空间后就不为null了）；
　　在JVM中的及时编译存在指令重排序的优化，也就是说不能保证1,2,3执行的顺序，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是 1-3-2，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。
　　通过添加volatile就可以解决这种报错，因为volatile可以保证1、2、3的执行顺序，没执行玩1、2就肯定不会执行3，也就是没有执行完1、2instance一直为空，具体代码如下：
---------------
is-a、has-a和is-like-a之间的关系

   is-a与has-a之间的关系

   可以看到  MyClass 继承自 A，它们是is-a关系。

   MyClass实现了接口I，它们是has-a关系。


    如果继承过程中，仅仅是覆盖了父类中的方法，则为is-a关系。

    如果有新增的方法，则为is-like-a关系。
---------------------
二叉树 
前序遍历  根 左 右
中序遍历  左 根 右
后序遍历  左 右 根
---------------------
CAS   compare-and-swap：CAS 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。
需要操作三个值 内存值 V  旧的预期值 A  新的值 B
当 A与V 相同时，将B赋值给V
volatile关键字的作用：https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9663799230599619543%22%7D&n_type=1&p_from=3
一：：每个线程都有一个自己的本地内存，所有线程共用一个主内存。如果一个线程对主内存中的数据进行了修改，而此时另外一个线程不知道是否已经发生了修改，就说此时是不可见的。这种不可见的情况会带来一个问题，两个线程有可能会操作同一份但是值不一样的数据，这时候就需要volatile关键字了、volitale关键字很简单，就是一个线程在对主内存的某一份数据进行更改时，改完之后会立刻刷新到主内存，并且会强制让缓存了该变量的线程中的数据清空，必须从主内存中重新读取最新的数据，这样一来就保证了可见性。
二：：程序执行的顺序按照代码的先后顺序执行就叫做有序性，但是有时候程序的执行并不会遵循(JVM可能发生指令重排序)，加了volatile关键字的字段就能防止指令重排序

缺点
1 循环时间长开销很大。
2 只能保证一个共享变量的原子操作。
3 ABA问题 V被修改过，但之后又修改回A。 
---------------------
继承是把双刃剑
继承虽然强大，但继承可能破坏封装，而封装可以说是程序设计第一原则，
继承还可能被误用，没有反映真正的"is-a"关系。
我们也介绍了如何应对继承的双面性，一方面是避免继承，使用final避免、优先使用组合、使用接口。
--------------------------------------
数据结构    栈
package com.xxx.europe.dieb;

import com.xxx.game.tabletop.item.card.Card;
import com.xxx.game.tabletop.item.card.CardEnum;
import com.xxx.game.tabletop.item.card.CardGroup;

import java.util.Arrays;
import java.util.EmptyStackException;

public class ArrayStack {
    //存储元素的数组,声明为Object类型能存储任意类型的数据
    private Object[] elementData;
    //指向栈顶的指针
    private int top;
    //栈的总容量
    private int size;


    //默认构造一个容量为10的栈
    public ArrayStack(){
        this.elementData = new Object[10];
        this.top = -1;
        this.size = 10;
    }

    public ArrayStack(int initialCapacity){
        if(initialCapacity < 0){
            throw new IllegalArgumentException("栈初始容量不能小于0: "+initialCapacity);
        }
        this.elementData = new Object[initialCapacity];
        this.top = -1;
        this.size = initialCapacity;
    }


    //压入元素
    public Object push(Object item){
        //是否需要扩容
        isGrow(top+1);
        elementData[++top] = item;
        return item;
    }

    //弹出栈顶元素
    public Object pop(){
        Object obj = peek();
        remove(top);
        return obj;
    }

    //获取栈顶元素
    public Object peek(){
        if(top == -1){
            throw new EmptyStackException();
        }
        return elementData[top];
    }
    //判断栈是否为空
    public boolean isEmpty(){
        return (top == -1);
    }

    //删除栈顶元素
    public void remove(int top){
        //栈顶元素置为null
        elementData[top] = null;
        this.top--;
    }

    /**
     * 是否需要扩容，如果需要，则扩大一倍并返回true，不需要则返回false
     * @param minCapacity
     * @return
     */
    public boolean isGrow(int minCapacity){
        int oldCapacity = size;
        //如果当前元素压入栈之后总容量大于前面定义的容量，则需要扩容
        if(minCapacity >= oldCapacity){
            //定义扩大之后栈的总容量
            int newCapacity = 0;
            //栈容量扩大两倍(左移一位)看是否超过int类型所表示的最大范围
            if((oldCapacity<<1) - Integer.MAX_VALUE >0){
                newCapacity = Integer.MAX_VALUE;
            }else{
                newCapacity = (oldCapacity<<1);//左移一位，相当于*2
            }
            this.size = newCapacity;
            elementData = Arrays.copyOf(elementData, size);
            return true;
        }else{
            return false;
        }
    }

    public static void main(String[] args) {
            CardGroup a = new CardGroup();
            a.addCard(new Card(CardEnum.CLUB_A,2,3));
            ArrayStack stack = new ArrayStack(3);
            stack.push(1);
            //System.out.println(stack.peek());
            stack.push("a");
            stack.push(3);
            stack.push("b");
            stack.push(2);
            stack.push(a);
            System.out.println(stack.peek());
            System.out.println(stack.peek().equals(a));
            stack.pop();
            stack.pop();
            stack.pop();
            System.out.println(stack.peek());
            System.out.println(stack.peek().equals(a));
            ArrayStack stack2 = new ArrayStack();
            String str = "how are you";
            char[] chars = str.toCharArray();
            for ( char s : chars) {
                stack2.push(s);
            }
            while (!stack2.isEmpty()){
            System.out.print( stack2.pop());
            }
            System.out.println();
    }


}
--------------------------------------------------------------------
数据结构       队列
package com.xxx.europe.dieb;

public class MyQueue {
    private Object[] queArray;
    //队列总大小
    private int maxSize;
    //前端
    private int front;
    //后端
    private int rear;
    //队列中元素的实际数目
    private int nItems;

    public MyQueue(int s){
        maxSize = s;
        queArray = new Object[maxSize];
        front = 0;
        rear = -1;
        nItems = 0;
    }

    //队列中新增数据
    public void insert(Object value){
        if(isFull()){
            System.out.println("队列已满！！！");
        }else{
            //如果队列尾部指向顶了，那么循环回来，执行队列的第一个元素
            if(rear == maxSize - 1){
                rear = -1;
            }
            //队尾指针加1，然后在队尾指针处插入新的数据
            queArray[++rear] = value;
            nItems++;
        }
    }

    //移除数据
    public Object remove(){
        Object removeValue = null ;
        if(!isEmpty()){
            removeValue = queArray[front];
            queArray[front] = null;
            front++;
            if(front == maxSize){
                front = 0;
            }
            nItems--;
            return removeValue;
        }
        return removeValue;
    }

    //查看对头数据
    public Object peekFront(){
        return queArray[front];
    }
    public Object peekRear(){
        return queArray[rear];
    }

    //判断队列是否满了
    public boolean isFull(){
        return (nItems == maxSize);
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return (nItems ==0);
    }

    //返回队列的大小
    public int getSize(){
        return nItems;
    }

    public static void main(String[] args) {
        MyQueue queue = new MyQueue(3);
        queue.insert("c");
        queue.insert("a");
        queue.insert("b");//queArray数组数据为[c,a,b]

        System.out.println(queue.peekFront()); //c
        System.out.println(queue.remove());//c、queArray数组数据为[null,2,3]
        System.out.println(queue.peekFront()); //a

        queue.insert("s");//queArray数组数据为[a,b,s]
        System.out.println(queue.peekFront());//a
        System.out.println(queue.peekRear());//s
        queue.insert(5);//队列已满,queArray数组数据为[a,b,s]
    }

}





















--------------------------
//有顺序的Map ，LinkedHashMap
 public static void main(String[] args) {
        Map<Integer,String> map = new LinkedHashMap<Integer,String>();
        map.put(3,"c张三");
        map.put(4,"d李四");
        map.put(5,"e王五");
        map.put(6,"f赵六");
        map.put(7,"g田七");
        map.put(1,"a武大");
        map.put(2,"b武二");
        Object iteratort = map.entrySet().iterator().next();
        Iterator iteratorw = map.entrySet().iterator();
        Object next = null;
        while (iteratorw.hasNext()) {
            next = iteratorw.next();
        }
        System.out.println(iteratort);
    }
------------------------------
基于双向链表实现无锁的队列
public class LockQueue<E> implements ILockQueue<E>{
    //双向链表队列 指向队列头结点的原子引用
    private AtomicReference<Node<E>> head = new AtomicReference<Node<E>>(null);
    //双向链表队列 指向队列尾结点的原子引用
    private AtomicReference<Node<E>> tail = new AtomicReference<Node<E>>(null);

    @Override
    public boolean enQueue(E e) {//存数据
        //创建一个包含入队元素的新结点
        Node<E> newNode = new Node<>(e);
        //死循环
        for (; ; ) {
            //记录当前尾结点，尾节点的next中存放的是其本身
            Node<E> taild = tail.get();
            //当前尾结点为null,说明队列为空
            if (taild == null) {//空的话，存储新节点,且 头尾节点的原子引用都是其本身
                //CAS方式更新队列头指针
                if (head.compareAndSet(null, newNode)) {
                    //非同步方式 更新 尾指针
                    tail.set(newNode);
                    return true;
                }
            } else {
                //新节点的prev中 存放着他前面节点的信息，
                newNode.prev = taild;
                //CAS方式将尾指针指向新的结点
                if (tail.compareAndSet(taild, newNode)) {
                    //非同步方式 将新节点的信息 存放到 旧节点的next中
                    taild.next = newNode;
                    return true;
                }
            }
        }
    }
    @Override
    public E deQueue() {
        //死循环
        for (; ; ) {
            //当前头结点
            Node<E> headed = head.get();
            //当前尾结点
            Node<E> tailed = tail.get();

            if (tailed == null) { //尾结点为null,说明队列为空,直接返回null（头结点也可以出来相同的效果，弊端未知）
                return null;
            } else if (headed == tailed) { //尾结点和头结点相同,说明队列中只有一个元素,此时要更新头尾指针
                //CAS方式更新尾指针为null
                if (tail.compareAndSet(tailed,null)) {
                    //头指针更新为null
                    head.set(null);
                    return headed.item;
                }

            } else {
                //走到这一步说明队列中元素结点的个数大于1,只要更新 队列头指针 指向 原头结点的下一个结点就行
                //但是要注意头结点的下一个结点可能为null,所以要先确保新的队列头结点不为null

                //队列头结点的下一个结点
                Node next = headed.next;
                if (next != null && head.compareAndSet(headed,next)){
                    next.prev = null;
                }
                return headed.item;
            }
        }
    }
    private static class Node<E> {
        public volatile Node prev;
        public volatile Node next;
        public E item;

        public Node(E item) {
            this.item = item;
        }
    }
    public static void main(String[] args) {
        LockQueue a = new LockQueue();
        a.enQueue("123");
       // a.enQueue("asd");
       a.enQueue("swq");
       a.enQueue("23x45");
        System.out.println(a.deQueue()); System.out.println(a.deQueue()); System.out.println(a.deQueue());
        // System.out.println(a.deQueue());
    }
}
------------------------------
下午看面向对象：设计模式，并简单实践

------------------------------
设计模式总结： 5+1种创建型，7种结构型，11种行为型
----------------
6种创建型模式:类的实例化
----------------
创建型模式对类的实例化过程进行了抽象，将软件模块中对象的创建和对象的使用分离。为了使软件结构更加清晰，外界对于这些对象只需要知道他们的共同接口，而不清楚具体的实现细节，使整个系统设计更符合单一职责原则。隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到了使整个系统独立的目的。

简单工厂模式：有一个基类，若干子类都继承该基类(接口),子类内部实现不同功能，然后有一个工厂类，定义一个方法，根据参数不同，返回不同子类的实例；违反了开闭原则；工厂干的太多，产品较多时，工厂方法代码将会非常复杂。。
简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。

工厂方法模式factory  ：简单工厂模式的升级版，将简单工厂中的工厂进行细分，分成一个工厂类(接口)和若干个子工厂，子工厂继承工厂类，工厂类负责提供生产产品的方法，每个子工厂对应一种子产品；
优点：是在系统中加入新产品的时候，无需修改抽象工厂和抽象产品提供的接口，无须修改客户端和具体工厂、具体产品，只要添加新的具体工厂和具体产品就可以了，符合开闭原则。
缺点：因为要加具体工厂和具体产品，所以会使系统中的类数量成对增加，增加了系统的复杂度，有更多的类需要编译和运行，还会给系统带来一些额外的开销。由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
例：JDBC中的工厂方法

抽象工厂abstactfactory：有一个抽象工厂基类，若干子工厂继承该基类，有若干产品基类，每个产品基类有若干子类继承，
抽象工厂基类里面声明了生产每个产品基类的方法，产品子工厂具体实现的时候 生成 来自不同产品基类 的子类。
抽象工厂和工厂方法模式相比，面对多个产品等级结构，而工厂方法模式针对的是一个产品等级结构。
是工厂方法模式的又一次功能升级，增加了产品结构(电视、冰箱)和产品族(海尔电视，海尔冰箱；华为电视，华为冰箱)的概念
当一个 工厂等级结构 可以创建出 分属于不同产品等级结构 的 一个产品族中 的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。
缺点：抽象工厂开闭倾斜，因为他可以很好的扩展产品族，只需要增加新的具体工厂，增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类。
抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。
{
工厂模式的退化
当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。
}

单例模式singleton：(前面有并发—懒汉单例模式的例子)以下是总结：
单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。
单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。
单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法。该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。
单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。
单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。


建造者模式builder：(创建环境地图的例子)。
模式结构：Builder：抽象建造者(或接口)，ConcreteBuilder：具体建造者，Director：指挥者，Product：产品角色
有一个抽象建造者，里面有若干抽象方法，有若干具体建造者，根据自身需要将抽象建造者中声明的方法具体化，有一个或多个指挥者，指挥者中定义方法，根据需求调用具体建造者中的方法，在实际调用时，可直接调用指挥者中的方法。

原型模式prototype：原型模式有一个接口类，需要实现标识接口Cloneable，声明了一个clone方法用于子类实现克隆，还要声明  使用方法，用于子类的具体方法实现，交给子类去实现具体功能，实现接口类的子类，只需要根据自身需求完成相应的方法，具体操作要在Main类中体现出区别(相对复杂)。此外需要一个Manager类，不需要和实现接口的子类有关联，只需要使用接口类，通过这个将Manager类和其他具体类连接起来，Manager用键值对注册实现了接口类的子类(作为值)，可以通过键取出来，并使用其实现的具体方法。
Manager类如下：
//保存实例的“名字”和“实例”之间的对应关系
    private HashMap<String, Product> showcase=new HashMap<String, Product>();
//register方法将接收到的一组“名字”和“Product接口”注册到showcase中。这里Product是实现Product接口的实例，具体还未确定
    public void register(String name ,Product product){
        showcase.put(name, product);
    }
    public Product create(String productname){
        Product p=showcase.get(productname);
        return p.creatClone();
    }
Main中的具体操作如下：
    Manager manager = new Manager();
        UnderlinePen underlinePen=new UnderlinePen('~');
        MessageBox mbox=new MessageBox('*');
        MessageBox sbox=new MessageBox('/');
        manager.register("Strong message", underlinePen);
        manager.register("Waring Box", mbox);
        manager.register("Slash Box", sbox);
        Product p1=manager.create("Strong message");
        p1.use("hello world");
        Product p2=manager.create("Waring Box");
        p2.use("hello world");
        Product p3=manager.create("Slash Box");
        p3.use("hello world");
原型模式角色分析：
--Prototype（抽象原型类）
Prototype角色负责定义用于复制现有实例来生成新实例的方法。在示例程序中的Product接口就是该角色。
--ConcretePrototype（具体原型类）
ConcretePrototype角色负责实现复制现有实例并生成新实例的方法。在示例程序中，MessageBox和UnderlinePen都是该角色。
--Client（客户类/使用者）
Client角色负责使用复制实例的方法生成新的实例。在示例程序中，Manager类扮演的就是该角色。

深克隆和浅克隆(深拷贝和浅拷贝)：Person p = new Person(); Person P1 = P;这是指向同一对象的不同引用，
Person p1 = (Person) p.clone();   这是指向的不同对象，但是不会拷贝Person对象中引用的其他对象，需要将Person的clone方法中加入Person对象中引用的其他对象，并且在引用对象中也需要重写clone方法，以此类推，完成深拷贝。如果引用对象还有引用对象的话，算是不彻底的深拷贝，彻底拷贝比较难，但对于Person来说已经算是深拷贝了。

类和对象：Java是面向对象的程序设计语言，对象是由类抽象出来的，所有的问题都是通过对象来处理，对象可以操作类的基本属性和方法解决相应的问题。

-----------
7种结构型:
结构型模式描述如何将类和对象结合在一起形成更大的结构。
-----------
-(类和对象之间的结构组成)
添加：桥接模式：将功能层次和实现层次分离的技术。功能层次：父类-子类-孙类...；实现层次：抽象类-（实现1，实现2，实现3....）。功能层次高度为n，实现层次高度一直为2。
桥接模式bridge(打断 了 骨头,却 还连着筋):将一个需要多维度变化的类分解,并在抽象层组合关联。
关键词：两个维度，m+n，抽象类中关联、接口。
https://www.cnblogs.com/not2/p/11017132.html 二、实战应用
设计意图：桥接模式不是将两个不相干的类连接起来，而是将一个需要多维度变化的类分解成抽象部分和实现部分，并且在抽象层对两者做组合关联，是用组合的方式解决问题。
例：在一个类中有两个维度分别有m和n种变化，采用继承的方式就需要扩展出m*n个子类，而且每个维度增加一种变化，就需要增加 另一种维度变化总量 个子类，如果将两个维度拆分再组合，加起来也只有m+n个子类，而且每个维度独立扩展，一个维度增加一种变化，只需要增加该维度的一个子类。桥接模式中的桥，个人理解在抽象化角色中，其中有一个队实现化对象的引用，而以此为参的构造方法就是桥，连接两个维度。、
ps:通过该模式的研读，我好像更加清晰的理解父子类之间的关系和接口及其实现类之间的关系了。
抽象化角色：抽象化角色中有一个对实现化对象的引用，有参构造方法和抽象方法。
修正抽象化角色：扩展 抽象化角色，改善和修正父类对抽象化的定义，具体父类的抽象方法。
实现化角色：这个角色代表的是一个接口，不给出具体实现。这个角色和抽象化角色定义很不一样，实现化角色应当只给出低层操作，抽象化角色应当只给出基于底层操作的更高一层的操作。
具体实现化角色：这个角色给出实现化角色接口的具体实现
解耦：在一个软件系统的抽象化和实现化之间使用关联关系(组合或聚合)而不是继承关系，从而使两者相对独立的变化，这就是桥接模式的用意。
存在一个接口和一个抽象类，抽象类中有一个接口的实例和参为接口的有参构造。
模式分析
理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。
抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。
实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。
脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。
适配器模式与桥接模式的联用:
桥接模式和适配器模式用于设计的不同阶段，桥接模式 用于系统的 初步 设计，对于 存在两个独立变化维度的 类 可以将其分为 抽象化 和 实现化 两个 角色，使它们 可以 分别 进行 变化；而在 初步设计 完成 之后，当发现 系统 与 已有类 无法 协同工作 时，可以 采用 适配器模式。但 有时候 在设计初期 也需要考虑适配器模式，特别 是那些 涉及到 大量 第三方 应用接口 的 情况。

适配器模式adapter：(是类结构型模式也是对象结构型模式)通过引用适配器 来重用现有的适配者类，提高了适配者类的复用性，同一适配者可以在不同系统中多次复用；灵活性和扩展性很好，通过配置文件，可以方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类。
-适配者类：程序中已有的方法
-适配器：适配器模式的核心，通过操作将适配者类中的方法转换成目标类/接口中所需要的方法，
-目标类/接口：想要调用 适配者类中的方法 的类
-客户类：调用适配器：目标接口  名字 = new 适配器类( ) ;
--类适配器模式：适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法;
优点：适配器是适配者的子类，所以可以根据需要置换一些适配者中的方法
缺点：像JAVA、C#等不支持多继承的语言，一个适配器只能适配一个适配者类，而且目标对象只能是抽象类，有局限性
--对象适配器模式：适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应 业务方法。
优点：可以将多个不同适配者适配到同一目标也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。
缺点：不方便置换适配者中的方法，如果想置换，只能通过适配者类的子类来置换其中的方法，然后将适配者类的子类当做适配者类来进行适配。
----*
适配器模式 用于 将一个接口 转换成 客户希望的另一个接口，适配器模式 使 接口不兼容的 那些类 可以一起工作 ， 其别名为 包装器。适配器模式 既可以 作为 类结构型模式，也可以作为 对象结构型模式。
适配器模式包含四个角色：目标抽象类 定义客户要用的 特定领域的 接口；适配器类 可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。
在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类(接口)的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。
目标接口  名字 = new 适配器类( ) ;
适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。
适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。
----*

装饰模式decorator：对象结构型模式，(包装模式)在IO用的最多的就是装饰者模式了;和代理模式的静态代理有些类似，易混淆，都是用于加强类，继承也是为了加强类。
结构：接口类(声明一些方法)，被装饰类(实现接口类并具体化其中的方法)，装饰者类(实现接口类，并定义接口类型的属性，以及有参构造方法,参为接口类型，重写接口方法，调用 定义的 接口类型的属性 中 的方法就行)，若干个 具体增强类(继承了装饰者类，重写父类方法时，调用super中的方法，并在其前或后加入自己需要的内容)，
类加强的方式：继承：继承父类，子类扩展；包装模式：使用包装的方式来增强子类；代理模式：静态代理，动态代理，静态代理和包装模式我看着就是一样啊。。。。虽然前面说了易混淆，但是我也不知道怎么区别。。；
那么只要遇到Java给我们提供的API不够用,我们增强一下就行了，在写代码时，某个类被写死了，功能不够用，加强一下就行了！

组合模式composite：(组合模式中，树形结构以表示'部分-整体'的层次结构)通过递归实现
组合对象是把一组组相似的对象当做单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次，他创建了对象组的树形结构。简单来说，就是根据树形结构把相似的对象进行组合，然后表示该部分是用来干啥的，就比如电脑中的 文件系统。文件系统由目录和文件组成，每个目录下都可以装内容，目录的内容可以是文件，也可以是目录。按照这种方式，计算机的文件系统就是以递归结构来组织的，

过滤器模式：就是过滤，根据自身需求，设置不同的条件，过滤。。。没啥东西(在网上看见的，不太典型。)

享元模式flyweight：享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池(通过键值对HashMap<K,FlyWeight>存取)，用户需要对象时，先去享元池中获取，如果享元池中不存在，则创建一个新对象存到享元池中并返回给用户。
模式分析：享元模式是一个考虑系统性能的设计模式，通过使用享元模式能节约内存空间，提高系统的性能。享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是内部状态和外部状态。
内部状态是内存在享元对象内部并且不会随环境变化(享元工厂中提供不同内容)而改变的对象；外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存(客户端在调用享元工厂中的方法时，需要提供一个外部对象，在此时保存，外部对象即享元池中的Key，)，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另外一个外部状态之间是相互独立的。

外观模式facade：(对象结构型模式)有若干个子系统类，通过一个外观角色类来控制。为子系统中的一组接口或一组功能提供一个一致的接口，外观模式定义了一个高层接口，使这一子系统更易使用；
去银行取钱，如果没有窗口服务小姐姐，我们需要自己数钱、自己找打印机、自己找银行领导签字等等。是不是很麻烦。有了窗口服务员，我们自需要和服务员交换，其他都不用关了。
所以，我们可以得到外观模式的关键代码在于：当客户端和复杂系统之间进行交换的时候，在两者之间在封装添加一层，这一层的作用就是将调用顺序、依赖关系等等都处理好的。



代理模式proxy：(对象结构型模式)有抽象主题角色，代理主题角色（代理对象、代理类），真实主题角色（委托对象、委托类）。例：代理主题角色可以在抽象主题角色的方法前后织入新的内容，抽象主题角色是一个接口，声明一个或多个方法，真实主题角色实现了抽象主题角色这个接口里的内容，将其声明的方法具体化。代理对象在委托对象和客户类（实际应用中、或测试类）之间起到中介隔离作用，特征是代理类和委托类实现相同接口（抽象主题角色）。代理类还可以增加额外的功能来拓展委托类的功能，这样的话只需要修改代理类，而不用修改委托类，符合开闭原则。代理类主要负责预处理消息，过滤消息，把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正的实现服务，而是调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类实现，但是可以在业务功能实现前后加入一些公共服务。例如想给项目加入缓存、日志等功能。可以在代理类加，而没必要打开已经封装好的委托类。
代理角色中声有一个抽象角色的实例，在测试类(或者实际应用)中调用代理角色的时候，在其构造方法中放入抽象角色的子类->真是角色，然后就会调用真实角色中已经具体过的方法，(代理类实现了抽象类接口并重写其中方法)再调用代理类中重写并增强过的方法，就可以了。
代理模式总结：在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用，代理模式包含三个角色：抽象主题角色，声明了真实主题和代理主题的共同接口；代理主题角色，内部包含对真实主题的引用，从而可以在任意时候操作真实主题对象；真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接的调用真实主题角色中定义的方法。代理模式的优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；其缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，代理模式的实现非常复杂(忽略。。),
如果按照 代理创建的时期来进行分类的话，可以分为两种：静态代理和动态代理。静态代理 是由程序员创建的或特定工具自动生成的源代码，再对其编译。在程序运行之前，代理类.class文件就已经被创建。动态代理 是在程序运行时通过反射机制动态创建的。
上面主要是简单的静态代理
简单的动态代理：需要实现InvacationHandler接口，重写其中的invok方法，定义一个Object属性，并提供有参的构造方法
 @Override
    public Object invoke(Object object, Method method, Object[] objects) throws Throwable {
        before();
        method.invoke(this.object,objects);
        after();
        return null;
    }

JDK实现动态代理需要 实现  类通过接口定义业务方法，对于 没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术 为 一个类 创建 子类，并 在 子类 中 采用 方法拦截 的 技术 拦截 所有父类方法 的 调用，顺势 织入 横切逻辑。但因为 采用的 是 继承，所以 不能 对 final修饰的类 进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。

动态代理总结：虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。

-------------
11种行为型:
-------------
不仅关注类和对象的结构，而且重点关注它们之间的相互作用。
-(类和对象之间的行为交互！、？)
通过行为型模式，可以 更加清晰地 划分 类与对象 的职责，并 研究系统在运行时 实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

行为型模式分为类行为型模式和对象行为型模式两种：
类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过 多态等方式来分配 父类与子类 的职责。
对象行为型模式：对象的行为型模式 则使用 对象的聚合关联关系 来分配行为，对象行为型模式 主要是通过 对象关联等方式来分配 两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。


 策略模式的核心在 使用者的策略，按照自己的策略去替换。模板方法模式核心在 子类怎么实现。(编程人员的目的点不同，，，？)
1.模板方法模式template：定义一个算法流程，将一些特定步骤的具体实现延迟到子类，使得可以在不改变算法流程的情况下，通过不同的子类，来实现“定制”流程中的特定步骤。
--(自己总结)就是有一个基类抽象类或接口，里面有声明的若干方法，若干个子类可以重写其中的方法，然后调用的时候通过new不同的子类，来调用不同的方法实现。
加：模板方法模式是在之前定义好的类的基础上，这个类有整个流程，但是如果有两个流程只有某些步骤不一样，那么
可以继承这个类，然后重写其中的自己不一样的方法，再调用类中的流程的时候，就会按流程中自定义的操作来操作了

2.策略模式strategy：
--(自己总结)和模板模式很相似，感觉真的没什么实质上的区别。。放个代码看着玩吧，，，
加：策略模式，参考插卡游戏机，面向接口编程，并是不像上面写的没有区别，逐渐理解吧

抽象策略
interface Strategy {
    //加密
    public void encrypt();
}
具体策略1
class MD5Strategy implements Strategy{
    public void encrypt() {
        System.out.println("执行MD5加密");
    }
}
具体策略2
class SHA1Strategy implements Strategy{
    public void encrypt() {
        System.out.println("执行SHA1加密");
    }
}
封装类
class Context {
    private Strategy strategy;
    public Context(Strategy strategy) {
        this.strategy = strategy;
        }
    public void encrypt() {
        this.strategy.encrypt();
    }
}
测试类
public class Test {
    public static void main(String[] args) {
        Context context = new Context(new MD5Strategy());
        context.encrypt();
    }
}
下面我们看一下策略模式，策略模式其实比较简单，相信大家都使用过，只不过不清楚而已，其实就是使用抽象类或者接口，定义一个方法，然后子类来实现相应的方法，之后通过一个新的类来使用这个已经定义好的组件，使用委托（组合）的方式，让定义的接口根据多态来灵活的使用相应的实现方法，最终完成一定的功能。和Builder模式比起来，Builder中新建的类还要对接口中的元素方法进行组合和操作，而策略模式只用一个方法就可以，没有这种复杂的操作，就是简单的使用已经定义好的方法，不用再次封装操作。和桥接模式相比，差别也是很明显的，桥接是功能层次和实现层次分离，而策略模式是方便扩充策略，但是这几种模式的某些部分是很类似的，只不过完成的任务有些许不同而已。

两个类之间：
3.观察者模式observer：
 观察者模式其实最好的名称应该是“发布订阅”模式，和我们现在大数据之中的发布订阅方式比较类似，但是也有区别的地方，在上一个设计模式，我们学习的是仲裁者模式，其中当控件的状态发生改变的时候就会向仲裁者发出信息，让仲裁者进行仲裁，这其实和发布订阅非常的类似，但是用处是不一样的，仲裁者模式是用来解除复杂对象之间的相互调用的关系，从而独立出来进行开发，而观察者模式是在被观察者状态改变的时候被动的被唤醒进行相应的处理，两者的实现比较类似，比如都是被动唤醒的，但是思想和用处是不一样的，被唤醒之后的处理是不一样的。
观察者模式(又称发布-订阅模式)，属于行为型模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象(被观察者)在状态发生变法时，会通知所有观察者对象，使他们能够自动更新自己的状态。其通知所有观察者对象的核心在于主题对象中的notify方法(或者别的名字),通过该方法遍历所有存储在列表中的观察者对象，并调用观察者中的update方法来向他们发送内容。
--总结
观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。
观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。
观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。
观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。
在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。

4.迭代器模式iterator（容器与容器遍历）：迭代器模式又叫游标模式，是一种对象的行为型模式。提供一种方法顺序访问一个聚合(就是一个对象的组合结构，比如集合、数组等)对象中的所有元素，而又不暴露该聚合的内部表示。迭代器模式的本质：控制访问聚合对象中的元素。
迭代器模式涉及到的角色及其职责如下：
抽象迭代器角色：一般是接口或抽象类，用来定义访问和遍历元素的接口，在此类中一般有First()方法，用来获得第一个元素；Next()方法，获得下一个元素；HasNext()方法，来判断是否有下一个元素；CurrentItem()方法，用来获取当前元素。根据需求自行添加其他方法。
具体迭代器角色：实现迭代类，实现父类的具体方法，实现对聚合对象的遍历，并跟踪遍历时的当前位置
抽象聚合角色：定义创建相应迭代器对象的接口
具体聚合角色：实现创建相应的迭代器对象

5.责任链模式chain of responsibility（责任链模式）（串的替换---可以使用链式操作）（牌型压制？）
责任链模式很像异常的捕获和处理，当一个问题发生的时候，当前对象看一下自己是否能够处理，不能的话将问题抛给自己的上级去处理，但是要注意这里的上级不一定指的是继承关系的父类，这点和异常的处理是不一样的。所以可以这样说，当问题不能解决的时候，将问题交给另一个对象去处理，就这样一直传递下去直至当前对象找不到下线了，处理结束。
如下图所示，处于同等层次的类都继承自Support类，当当前对象不能处理的时候，会根据预先设定好的传递关系将问题交给下一个人，可以说是“近水楼台先得月”，就看有没有能力了。我们也可以看作是大家在玩一个传谜语猜谜底的小游戏，按照座位的次序以及规定的顺序传递，如果一个人能回答的上来游戏就结束，否则继续向下传，如果所有人都回答不出来也会结束。这样或许才是责任链的本质，体现出了同等级的概念。
总结：责任链使用了模板方法和委托的思想构建了一个链表，通过遍历链表来一个个询问链表中的每一个节点谁可以处理某件事情，如果某个节点能够胜任，则直接处理，否则继续向下传递，如果都不能处理next==null，则处理结束。责任链会造成处理的延时，但是能够解耦合，提高可扩展性，使得处理方法的类更专注于处理自己的事情，便于扩展和改变处理的优先级，应用也非常的广泛。

6.命令模式command：(对象行为型模式)命令也是类，将命令作为一个类来保存；Invoker可以连接抽象命令类(实际调用时可直接传入具体命令类)，具体命令类可以连接抽象命令类和Receiver(Receiver像是一个操作集合类--自己感觉。。)
Invoker调用者/请求者：请求的发送者，不需要和请求的执行者直接发生关系，而是通过抽象命令类(Command)间接和请求执行者发生关联。Ivoker持有Command类的引用。
Command抽象命令类：里面声明了若干个需要的命令，主要就是execute()执行命令操作
ConcreteCommand具体命令类：(连接了抽象命令类和接受者。)实现了抽象命令类，并具体化了其中声明的方法，通过调用接受者间接实现了请求，但在调用之前和之后都可以进行某些操作完成记录、撤销或重做等操作。ConcreteCommand持有Receiver(接受者)的引用。
Receiver接受者：其中定义了各种各样的自身需求的命令，执行与请求相关的操作，具体实现请求的业务处理。
Test测试类：在测试类中创建调用者对象、具体命令类对象，同时指定请求接受者对象，因此请求的发送者和接受者之间没有直接的关联。
在Invoker中通过Command的引用，设置set方法，定义doCommand方法(方法内执行的是Command引用中得Command中声明的方法，)，之后引用的时候需要在setCommand方法中提供Command的实现子类，再调用doCommand方法的时候，即可调用之前所提供的Command的实现子类中重写的方法了。
当要使用的时候可以直接拿来使用，比如脚本语言写出的脚本，只需要一个命令就能执行得到我们想要的 需要操作很长时间才能得到的 结果。这是一个非常有意思的模式，将 操作的步骤 保存下来，本例之中我们使用java自带的GUI来画图，然后将画图的过程（在哪个地方画了什么东西）保存下来，
可以把 每一次我们的操作 作为一个命令，其实就是<使用什么画布，画点的坐标>，将 这个命令 对应的对象 保存到 所有命令对象的 集合之中去，这样命令集合就记录下来了每一个命令，如果要显示画的内容的时候，直接将这些命令 组合读取 出来在进行一次 重画 即可。通过这种模式 保存下来 已经执行的 步骤，
通过重画再复述出来，是一种非常重要的开发理念，在需要保存历史纪录并恢复的场合是非常有用的。
--模式分析
命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。
每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。
命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。
命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。
命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。
--模式扩展
宏命令又称为组合命令，它是命令模式和组合模式联用的产物。
-宏命令也是一个具体命令，不过它包含了对其他命令对象的引用，在调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法，一个宏命令的成员对象可以是简单命令，还可以继续是宏命令。执行一个宏命令将执行多个具体命令，从而实现对命令的批处理。
--总结
在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。
**(注意)命令模式包含四个角色：抽象命令类中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，
它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。··· ···
命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。
命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。
命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。
优点：降低了系统的耦合度；新的命令可以很容易的添加到系统中。缺点：使用命令模式可能会产生很多具体命令类。

类的状态：
7.备忘录模式memento：2
意图：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后恢复到之前保存的状态。
关键代码：客户不与备忘录类耦合，与管理备忘录的类耦合。
应用实例：1、后悔药 2、打游戏时的存档 3、Windows里的ctrl+z 4、IE中的后退 5、数据库中的事务管理
优点：1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史状态。 2、实现了信息封装，使得用户不需要关系状态的保存细节
缺点：消耗资源。如果类的成员变量过多，势必会占用较大的资源，而且每一次保存都会消耗一定的内存。
使用场景：1、需要保存/恢复数据的相关状态场景。 2、提供一个可以回滚的操作。
注意事项：1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可以使用原型模式+备忘录模式。
角色：
Originator（原发器）：他是一个普通类，可以创建一个备忘录，用备忘录存储它的当前内部状态。也可以用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器。。
Memento（备忘录）：存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，也可以随机应变，即根据需要保存的原发器的内部状态信息，来设定备忘录中相应的字段。需要注意的是，除了原发器本身和负责人类(即保存备忘录的类)之外，
备忘录对象不能直接提供给其他类使用，原发器的设计在不同编程语言中的实现机制会有所不同。
CareTaker（负责人）：负责人又称管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，他只负责存储备忘录对象，而不能修改对象，也无需知道对象的实现细节。
备忘录模式的核心是备忘录类以及用于管理备忘录的负责人类的设计。


8.状态模式state：状态模式有一个State(状态)接口，改变状态就是改变实现方式，改变其具体行为。状态模式就是根据对象内部不同状态的改变，来改变其行为。和策略模式极其相似。但是他与策略模式的区别在于，这种转换是 "自动","无意识的"。(前面看的，感觉策略模式和模板方法模式也比较像）
允许对象在当内部状态改变时改变其行为，就好像此对象改变了自己的类一样。面向对象设计其实就是想要做到代码责任的分解，遵循“单一职责原则”。
其实，状态模式主要解决的是，当控制一个对象状态转换的表达式过于复杂的情况下，把他状态判断的逻辑转移到表示不同的一系列类当中，可以把复杂的逻辑判断简单化。
 状态模式在某些场合中使用是非常方便的，什么叫做状态，如果大家学过《编译原理》就会明白DFA M和NFA M，在 确定有限状态机 和 非确定有限状态机 中，状态就是最小的单元，当满足某种条件的时候，状态就会发生改变，我们可以把时间中的一个时刻当做一个状态，那么其实整个社会都是有状态组成的，前一时刻到下一时刻，整个社会上的物质（空间）发生了什么样的变化，因此状态可以非常的大也可以非常的小，天气变化情况是状态，白天和黑夜也是状态，人的生活作息等等都是状态，因此状态无处不在。那么状态模式就是将一个状态看做一个类，这与以往我们对类的理解不一样，以往我们认为类是对对象的抽象，用来表示对象的，对象一般是具体的事物，而现在我们将状态这种抽象的事物当做类描述的东西，这一点可能需要大家理解。
    那么为什么必须要状态模式，不用状态模式可以吗？当然可以，但是还是回到了代码的可维护性、可扩展性、可复用性这个层面上来考虑问题，比如我们本例的内容，考虑一个银行系统，可以用来取款、打电话、报警、记录这四种功能，但是考虑如下需求：在白天如果我们去取款是正常的，晚上取款就要发出警报；在白天打电话有人接，晚上打电话启动留言功能；白天和晚上按警铃都会报警。那么我们应该如何设计这个程序呢，当然我们可以对每一个动作（作为一个函数），在这个函数内部，我们进行判断是白天还是黑夜，然后根据具体的情况做出反应。这样当然是可以的，但是假如我们的状态（白天和黑夜）非常的多呢，比如将24小时分成24个时间段（24个状态），那么我们对于每一个函数就要判断24遍，这无疑是非常糟糕的代码，可读性非常的差，并且如果需求发生了改变，我们很难去修改代码（很容易出现错误），但是如果我们考虑将这些状态都作为一个类，在每一个类内部进行处理、判断和相应的切换，这样思路就非常的清晰，如果再增加一种状态，代码需要修改的地方会非常的少，对于状态非常多的情景来说非常的方便。
三、总结
   可以看到状态模式的强大威力，是用最简洁的代码通过接口、抽象类、普通类、继承、委托、代理模式等方式，将状态抽象为类，然后通过控制状态的逻辑委托不同的状态去做不同的事情，对于每一个状态来说又再次委托控制状态的逻辑做出相应的动作和修改，这样看起来比较复杂，其实仔细阅读就会发现因为接口（抽象类）的原因，使得程序非常的简洁，各个状态分工明确，密切配合。
   但是状态模式也有一些缺点，正是因为各个状态密切配合，在一个状态之中要知道其他状态的对象，这就造成了一定的关联，状态与状态之间是一种紧耦合的关系，这是状态模式的一点缺点，针对于这一点，我们可以将状态迁移的代码统一交给SafeFrame来做，这样就要使用到了Mediator仲裁者模式了。
   使用单例的原因是如果一直创造新的对象会对内存产生浪费，因此单例即可。同样的使用状态模式通过接口使用state变量来表示相应的状态，不会产生混淆和矛盾，相比于使用多个变量来分区间表示状态来说是非常清晰简练的。State模式便于增加新的状态（也需要修改其他状态的状态迁移代码），不便于增加新的“依赖于状态的处理”，比如doAlarm等，因为一旦增加了，实现了State接口的所有状态都要增加该部分代码。
   同时我们也看到了实例的多面性，比如SafeFrame实例实现了ActionListener接口和Context接口，那么就可以将new SafeFrame()对象传入fun1(ActionListener a)和fun2(Context context)这两个方法之中，之后这两个方法对该对象的使用是不同的，权限也不一样，因此多接口就会产生多面性。状态模式其实是用了分而治之的思想，将不同的状态分开来讨论，抽取共同性，从而使问题变得简单。



通过中间类：

9.访问者模式visitor：1   在被访问类的数据结构不发生变化的情况下(没有新增和删除)，可以很方便的增加新的一种访问方式，只需要新增加一个访问类即可，但是如果我们的数据结构发生变化后，就需要修改继承自Visitor类的所有类了，这也违背了开闭原则，因此我们应该认真考虑，到底我们的数据结构是定死的还是经常变化的。
访问者基类中的抽象方法和被访问元素的数量理论上是一致的，
最复杂的设计模式，并且使用频率不高。《设计模式》的作者评价为：大多情况下，你不需要使用访问者模式，但是一旦需要使用它的时候，那就真的需要使用了。访问者模式是一种将 数据操作 和 数据结构 分离的设计模式。
使用场景：对象结构比较稳定，但经常需要在此对象结构上定义新的操作；需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。
角色介绍：Visitor：接口或者抽象类，定义了对每个Element访问的行为，它的参数就是被访问的元素，它的方法个数理论上与元素的个数是一样的，因此，访问者模式要求元素的类型要稳定，如果经常添加、移除元素类，必然会导致频繁的修改Visitor接口，如果出现这种情况，则说明不适合使用访问者模式。
ConcreteVisitor：具体访问者，他需要给出 对每一个元素类访问时 所产生的具体行为。
Element：元素的接口或抽象类，它定义了一个接受访问者的方法，其意义是指每个元素都要可以被访问者访问。
ConcreteElement：具体的元素类，它提供接受访问的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。
ObjectStructure：定义当中所提到的对象结构，对象结构是一个抽象表述，它内部管理了 元素集合，并且可以迭代这些元素来 提供给 访问者 访问。
总结
我们要根据具体情况来评估是否适合使用访问者模式，例如，我们的对象结构是否足够稳定，是否需要经常定义新的操作，使用访问者模式是否能优化我们的代码，而不是使我们的代码变得更复杂。
--优点。
各角色职责分离，符合单一职责原则：通过UML类图和上面的示例可以看出来，Visitor、ConcreteVisitor、Element 、ObjectStructure，职责单一，各司其责。
具有优秀的扩展性：如果需要增加新的访问者，增加实现类 ConcreteVisitor 就可以快速扩展。
使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化：员工属性（数据结构）和CEO、CTO访问者（数据操作）的解耦。
--缺点。
具体元素对访问者公布细节，违反了迪米特原则：CEO、CTO需要调用具体员工的方法。
具体元素变更时导致修改成本大：变更员工属性时，多个访问者都要修改。
违反了依赖倒置原则，为了达到“区别对待”而依赖了具体类，没有以来抽象：访问者 visit 方法中，依赖了具体员工的具体方法。

10.中介模式mediator：2 ---用一个中介对象来封装一系列对象的交互，中介者使各个对象之间不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
Mediator模式又称为仲裁者模式或者中介者模式，所起的作用是仲裁和中介，帮助其它类之间进行交流。在仲裁者模式之中，我们要明确两个概念，那就是仲裁者（Mediator）和组员（Colleague），不管组员有什么事情，都会向仲裁者汇报，仲裁者会根据全局的实际情况向其他Colleague作出指示，共同完成一定的逻辑功能。 
角色：
Mediator(抽象中介者):它定义一个接口，该接口用于与各同事对象之间进行通信。
ConcreteMediator(具体中介者):他是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了各个同事对象的引用。
Colleague(抽象同事类):它定义各个同事类公有的方法，并声明了一些抽象方法，同时它维持了对抽象中介类的引用，它的子类可以通过该引用来与中介者通信。
ConcreteColleague(具体同事类):它是抽象同事类的子类；每个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的方法。
中介者模式的核心在于中介者类的引入，在中介者模式中，中介者类承担了两方面责任：
--中转作用(结构性)：通过中介者提供的中转作用，各个同事对象就不需要再显式的引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用，该中转作用属于中介者在结构上的支持。
--协调作用(行为性)：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致的和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。
优点：简化了对象之间的交互，将各同事对象解耦，
缺点：具体中介者类包含了大量同事之间的交互细节，可能会导致其非常复杂，使得系统难以维护。(也就是把具体同事类之间的交互复杂性集中到了中介者类中，结果中介者成了最复杂的类)
总结
   对我们的程序而言，仲裁者模式适合于某一个部分发生改变就会导致其他部分做出相应的改变的情况，我们将这种变换的规律抽象出来，变成仲裁者，从而很好的协商各个部分，当组员有问题的时候（状态发生改变），直接告诉仲裁者，不与其他组员打交道，让仲裁者负责这些繁琐的事务，这样条理就很清晰了，因此仲裁者也成为中介者，可以想象很多人要去租房，很多人要把房子出租，如果私下里面去商量，既浪费时间，又很难找到对方，通过中介这个对象，它收集了很多的租房和出租房的信息，这样就能很快的找到最适合的房子。由此可见生活就是最好的设计模式。仲裁者模式对于代码的修改（很容易定位错误）、新的成员的加入、代码的复用（组员部分可以复用，仲裁者部分不易复用）都有着一定的简化，将该集中处理的集中起来，将该分散的分散出去，无疑是一种好的设计模式。对比于外观模式Facade，仲裁者需要和组员沟通，是双向的，而外观模式facade角色只是对其他角色进行整合，是单向的。设计模式至今我们已经研究了16种了，这其中很多设计模式都是有着关联的，同样也有着不同之处，但是都和实际问题是分不开的，设计模式是实际问题的抽象和解决方法，为了提高可扩展性和组件化，实际问题是设计模式的来源和最终归宿。
---ps：同事类中需要用到中介者中的方法，中介者中有每个同事类的引用，以次构成了以中介者为核心的 各同事类之间的 交互模式，


11.解释器模式interpreter：1	可利用场景比较少，Java中如果用到的话，可以用expression4J代替。
解释器模式提供了评估语言的语法或表达式的方式，这种模式实现了一个表达式接口，该借口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。
如何解决：构建语法树，定义终结符与非终结符。
关键代码：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。
包含角色：抽象表达式角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法（）
终结符表达式角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结符表达式与之相对应。
非终结符表达式角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。
环境角色：通常包含各个解释器需要的数据或者是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。
客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。


一，创建型/故事：
创建类
一个人“单例模式”根据一个工厂“工厂方法模式”的原型“原型模式”创建“建造者模式”出另一个工厂“抽象工厂”。

二，结构型/故事：
类与类结合
A代替“代理模式”B去相亲，A照着B的样子装扮自己“装饰模式”，穿上上衣,裤子,帽子组成“组合模式”B的外观样子“外观模式”，模仿B的行为来适配B“适配器模式”，在桥上与美女接头“桥接模式”，结构A相中了美女，一起共享“享元模式”了晚餐“。

三，行为型/故事

观察者A“观察者模式” 在观察电台，结果发现访问者“访问者模式”黑客B，A 报告给 Boss，Boss让中介者 C“中介者模式” 来破译这些命令“命令模式”，中介者 C 用各种策略“策略模式”来破译“解释器模式”这个连环的链式“职责链模式”的必须用迭代器“迭代器模式”才能解开这个命令，然后记录“备忘录模式”下来访问者 B 的信息状态“状态模式”，形成模版“模版方法模式”，为后人栽树。

--------
CgLib：
--------
CgLib是什么？
CgLib是一个强大的、高性能的代码生成包。广泛的被许多AOP框架所使用，为它们提供方法拦截。
--------
游戏编程中状态机的实现方式，有两种可以选择：

用枚举配合switch case语句。
用多态与虚函数（也就是状态模式）
--------
null和空字符的区别：

1、NULL：代表声明了一个空对象，不是一个字符串，可以赋给任何对象。 

空字符：代表声明了一个对象实例，这个对象实例的值是一个长度为0的空字符串。

2、String s=null; 只是定义了一个句柄，即你有了个引用，但是这个引用未指向任何内存空间。

String s=”“; 这个引用已经指向了一块是空字符串的内存空间，是一个实际的东东了，所以可以对它操作。

String s=”a”和String s=new String(“a”);是有本质上的区别的 ：

(1) 前者是在字符串池里写入一个字符’a’,然后用s指向它； 后者是在堆上创建一个内容为”a”的字符串对象。

(2) String str=“aaa”; //于栈上分配内存 ；String str=new String(“aaa”); //于堆上分配内存

请添加详细解释
--------
汇编语言：
汇编语言是一种最低级、最古老、不具有移植性的编程语言，它能够直接访问计算机硬件，所以执行效率极高，占用资源极少，一般用于嵌入式设备、驱动程序、实时应用、核心算法等。汇编语言的缺点是开发周期特别长，实现一个简单的功能都非常麻烦，已经很少用来编写应用程序了。





















------------------------------

常用流的中间操作和终端操作

常用流的中间操作
filter使用:过滤掉不符合断言判断的数据
map使用:将一个元素转换成另一个元素
flatMap使用:将一个对象转换成流
peek使用:遍历操作
sorted使用:排序
distinct使用:去重
根据对象中的单属性去重
List<UploadSampleInfo> sampleInfoList2 = 去重的集合.stream().filter(distinctByKey(集合中的类::属性字段)).collect(Collectors.toList());

static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {
        Map<Object, Boolean> seen = new ConcurrentHashMap<>();
        return t -> seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
}

skip使用:跳过前几条

limit使用:取限制条数数据
常用流的终端操作
allMatch使用:所有元素匹配返回true
anyMatch使用:任何元素匹配返回true
noneMatch使用:任何元素都不匹配返回true
findFirst使用:找到第一个
findAny使用:找到任意一个
max使用:获取最大值
min使用:获取最小值
count使用:获取集合个数


------------------------------
UML
单向实线空心三角：继承关系（指向父类）
单向虚线空心三角：实现关系（指向父接口）
单向虚线箭头：依赖关系（一个类中引用了另一个类，这是一种很弱的关系（指向被引用的类））
单向实线箭头：单向关联关系（一个类知道或引用了另一个类，而另一个类不知道或没引用这个类。这种关系是比较持久的，稳定的。指向被应用或者被包含的类）
实线：双向关联关系（和单向关联不同的是，两个类彼此都知道对方的存在，即互相引用，用不带箭头的实线连接）
单向实线空心菱形：聚合关系（聚合关系是一种特殊的关联关系，他强调整体和部分的关系，其中部分可以脱离整体而存在（比如大雁和雁群，制服和警察）指向整体）
单向实线实心菱形：组合关系（组合关系也是一种特殊的关联关系，也强调整体和部分的关系，其中部分不可以脱离整体而存在（比如手和人）指向整体）

其中，依赖、关联、聚合、组合关系中的强度关系为：组合>聚合>关联>依赖。

————————————————
SimpleDateFormat格式大全
如下:
字母	日期或时间元素		表示		            示例
G	Era 标志符		        Text		            AD
y	    年	                Year	            	1996; 96
M	年中的月份		        Month		            July; Jul; 07
w	年中的周数		        Number		            27
W	月份中的周数		        Number		            2
D	年中的天数		        Number		            189
d	月份中的天数		        Number		            10
F	月份中的星期		        Number		            2
E	星期中的天数		        Text		            Tuesday; Tue
a	Am/pm 标记		        Text	            	PM
H	一天中的小时数（0-23）	Number		            0
k	一天中的小时数（1-24）	Number		            24
K	am/pm 中的小时数（0-11）	Number		            0
h	am/pm 中的小时数（1-12）	Number		            12
m	小时中的分钟数		    Number		            30
s	分钟中的秒数		        Number		            55
S	毫秒数			        Number		            978
z	时区			        General time zone	    Pacific Standard Time; PST; GMT-08:00
Z	时区			        RFC 822 time zone	    -0800
————————————————
Jul 23, 2020 8:53:35 AM
MMM dd, yyyy k:mm:ss a












